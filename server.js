const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Connexion MongoDB Atlas
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://username:password@cluster.mongodb.net/lotato';
mongoose.connect(MONGODB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
}).then(() => console.log('âœ… MongoDB Atlas connectÃ©'))
  .catch(err => console.error('âŒ Erreur MongoDB:', err));

// SchÃ©mas Mongoose
const userSchema = new mongoose.Schema({
    userId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    email: { type: String },
    phone: { type: String },
    password: { type: String, required: true },
    role: { type: String, enum: ['owner', 'supervisor', 'agent'], required: true },
    supervisorId: { type: String },
    location: { type: String },
    commission: { type: Number, default: 5 },
    online: { type: Boolean, default: false },
    blocked: { type: Boolean, default: false },
    createdAt: { type: Date, default: Date.now }
});

const ticketSchema = new mongoose.Schema({
    ticketId: { type: String, required: true, unique: true },
    agentId: { type: String, required: true },
    agentName: { type: String, required: true },
    supervisorId: { type: String },
    drawId: { type: String, required: true },
    drawName: { type: String, required: true },
    bets: [{
        game: String,
        number: String,
        cleanNumber: String,
        amount: Number,
        isAutoGenerated: Boolean,
        specialType: String,
        gain: { type: Number, default: 0 }
    }],
    total: { type: Number, required: true },
    checked: { type: Boolean, default: false },
    date: { type: Date, default: Date.now },
    printed: { type: Boolean, default: false }
});

const drawSchema = new mongoose.Schema({
    drawId: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    time: { type: String, required: true },
    active: { type: Boolean, default: true },
    results: {
        lot1: String,
        lot2: String,
        lot3: String,
        publishedAt: Date
    },
    sales: { type: Number, default: 0 },
    createdAt: { type: Date, default: Date.now }
});

const blockedItemSchema = new mongoose.Schema({
    type: { type: String, enum: ['number', 'draw', 'agent'], required: true },
    value: { type: String, required: true },
    reason: String,
    blockedBy: String,
    blockedAt: { type: Date, default: Date.now }
});

const gameRuleSchema = new mongoose.Schema({
    game: { type: String, required: true, unique: true },
    multiplier: { type: Number, required: true },
    description: String,
    updatedAt: { type: Date, default: Date.now }
});

const activityLogSchema = new mongoose.Schema({
    action: { type: String, required: true },
    userId: { type: String, required: true },
    userRole: { type: String, required: true },
    details: mongoose.Schema.Types.Mixed,
    timestamp: { type: Date, default: Date.now }
});

const numberLimitSchema = new mongoose.Schema({
    number: { type: String, required: true, unique: true },
    max: { type: Number, required: true },
    current: { type: Number, default: 0 },
    updatedAt: { type: Date, default: Date.now }
});

// ModÃ¨les
const User = mongoose.model('User', userSchema);
const Ticket = mongoose.model('Ticket', ticketSchema);
const Draw = mongoose.model('Draw', drawSchema);
const BlockedItem = mongoose.model('BlockedItem', blockedItemSchema);
const GameRule = mongoose.model('GameRule', gameRuleSchema);
const ActivityLog = mongoose.model('ActivityLog', activityLogSchema);
const NumberLimit = mongoose.model('NumberLimit', numberLimitSchema);

// Middleware d'authentification
const authenticate = async (req, res, next) => {
    try {
        const token = req.header('Authorization')?.replace('Bearer ', '');
        
        if (!token) {
            return res.status(401).json({ error: 'Token manquant' });
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'lotato-secret-key');
        const user = await User.findOne({ userId: decoded.userId });

        if (!user) {
            return res.status(401).json({ error: 'Utilisateur non trouvÃ©' });
        }

        if (user.blocked) {
            return res.status(403).json({ error: 'Compte bloquÃ©' });
        }

        req.user = user;
        req.token = token;
        next();
    } catch (error) {
        console.error('Auth error:', error);
        res.status(401).json({ error: 'Token invalide' });
    }
};

// ==================== ROUTES PUBLIQUES ====================

// Route de santÃ©
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'OK', 
        timestamp: new Date().toISOString(),
        mongo: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected'
    });
});

// Route de login
app.post('/api/auth/login', async (req, res) => {
    try {
        const { userId, password } = req.body;
        
        if (!userId || !password) {
            return res.status(400).json({ error: 'ID utilisateur et mot de passe requis' });
        }

        const user = await User.findOne({ userId });
        
        if (!user) {
            return res.status(401).json({ error: 'Identifiants incorrects' });
        }

        // Comparaison directe (pas de hash comme demandÃ©)
        if (user.password !== password) {
            return res.status(401).json({ error: 'Mot de passe incorrect' });
        }

        // Mettre Ã  jour le statut en ligne
        user.online = true;
        user.lastLogin = new Date();
        await user.save();

        // CrÃ©er un token JWT
        const token = jwt.sign(
            { 
                userId: user.userId, 
                role: user.role,
                name: user.name
            },
            process.env.JWT_SECRET || 'lotato-secret-key',
            { expiresIn: '24h' }
        );

        // Log d'activitÃ©
        await ActivityLog.create({
            action: 'LOGIN',
            userId: user.userId,
            userRole: user.role,
            details: { ip: req.ip }
        });

        res.json({
            success: true,
            token,
            user: {
                userId: user.userId,
                name: user.name,
                role: user.role,
                location: user.location,
                commission: user.commission,
                supervisorId: user.supervisorId,
                email: user.email,
                phone: user.phone
            }
        });
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'Erreur serveur lors de la connexion' });
    }
});

// Route de dÃ©connexion
app.post('/api/auth/logout', authenticate, async (req, res) => {
    try {
        req.user.online = false;
        await req.user.save();

        await ActivityLog.create({
            action: 'LOGOUT',
            userId: req.user.userId,
            userRole: req.user.role,
            details: { timestamp: new Date() }
        });

        res.json({ success: true, message: 'DÃ©connexion rÃ©ussie' });
    } catch (error) {
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Obtenir les tirages actifs
app.get('/api/draws', async (req, res) => {
    try {
        const draws = await Draw.find({ active: true }).sort({ time: 1 });
        res.json(draws);
    } catch (error) {
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Obtenir les rÃ¨gles de jeu
app.get('/api/game-rules', async (req, res) => {
    try {
        const rules = await GameRule.find();
        if (rules.length === 0) {
            // RÃ¨gles par dÃ©faut
            const defaultRules = [
                { game: 'borlette_lot1', multiplier: 60, description: 'Borlette 1er lot' },
                { game: 'borlette_lot2', multiplier: 20, description: 'Borlette 2Ã¨me lot' },
                { game: 'borlette_lot3', multiplier: 10, description: 'Borlette 3Ã¨me lot' },
                { game: 'lotto3', multiplier: 500, description: 'Lotto 3 chiffres' },
                { game: 'lotto4', multiplier: 1000, description: 'Lotto 4 chiffres' },
                { game: 'lotto5', multiplier: 5000, description: 'Lotto 5 chiffres' },
                { game: 'mariage', multiplier: 1000, description: 'Mariage' }
            ];
            await GameRule.insertMany(defaultRules);
            res.json(defaultRules);
        } else {
            res.json(rules);
        }
    } catch (error) {
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// ==================== ROUTES AGENT ====================

// Enregistrer un ticket
app.post('/api/tickets', authenticate, async (req, res) => {
    try {
        const { drawId, drawName, bets, total } = req.body;
        
        if (!drawId || !drawName || !bets || bets.length === 0) {
            return res.status(400).json({ error: 'DonnÃ©es de ticket incomplÃ¨tes' });
        }

        // VÃ©rifier que l'utilisateur est un agent
        if (req.user.role !== 'agent') {
            return res.status(403).json({ error: 'Seuls les agents peuvent crÃ©er des tickets' });
        }

        // VÃ©rifier si le tirage est actif
        const draw = await Draw.findOne({ drawId, active: true });
        if (!draw) {
            return res.status(400).json({ error: 'Tirage non disponible' });
        }

        // CrÃ©er le ticket
        const ticket = await Ticket.create({
            ticketId: `TKT-${Date.now()}-${Math.random().toString(36).substr(2, 4).toUpperCase()}`,
            agentId: req.user.userId,
            agentName: req.user.name,
            supervisorId: req.user.supervisorId,
            drawId,
            drawName,
            bets,
            total,
            date: new Date()
        });

        // Mettre Ã  jour les ventes du tirage
        await Draw.findOneAndUpdate(
            { drawId },
            { $inc: { sales: total } }
        );

        // Mettre Ã  jour les limites de nombres
        for (const bet of bets) {
            if (bet.game === 'borlette' && bet.cleanNumber) {
                await NumberLimit.findOneAndUpdate(
                    { number: bet.cleanNumber },
                    { $inc: { current: bet.amount } },
                    { upsert: true, new: true }
                );
            }
        }

        // Log d'activitÃ©
        await ActivityLog.create({
            action: 'TICKET_CREATED',
            userId: req.user.userId,
            userRole: req.user.role,
            details: { 
                ticketId: ticket.ticketId, 
                total, 
                drawName,
                betsCount: bets.length 
            }
        });

        res.status(201).json({ 
            success: true, 
            ticketId: ticket.ticketId,
            message: 'Ticket enregistrÃ© avec succÃ¨s',
            ticket: ticket
        });
    } catch (error) {
        console.error('Ticket error:', error);
        res.status(500).json({ error: 'Erreur lors de l\'enregistrement du ticket' });
    }
});

// Obtenir les tickets d'un agent
app.get('/api/agent/tickets', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'agent') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© aux agents' });
        }

        const { startDate, endDate } = req.query;
        let query = { agentId: req.user.userId };
        
        if (startDate && endDate) {
            query.date = {
                $gte: new Date(startDate),
                $lte: new Date(endDate)
            };
        }
        
        const tickets = await Ticket.find(query)
            .sort({ date: -1 })
            .limit(100);
        
        res.json(tickets);
    } catch (error) {
        console.error('Get tickets error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Obtenir le rapport journalier d'un agent
app.get('/api/agent/reports/daily', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'agent') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© aux agents' });
        }

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);

        const tickets = await Ticket.find({
            agentId: req.user.userId,
            date: { $gte: today, $lt: tomorrow }
        });

        const totalTickets = tickets.length;
        const totalBets = tickets.reduce((sum, ticket) => sum + ticket.bets.length, 0);
        const totalSales = tickets.reduce((sum, ticket) => sum + ticket.total, 0);
        const totalWins = tickets.reduce((sum, ticket) => 
            sum + ticket.bets.reduce((betSum, bet) => betSum + (bet.gain || 0), 0), 0);
        const totalLoss = totalSales - totalWins;
        const balance = totalWins - totalSales;

        // Statistiques par jeu
        const gameStats = {};
        tickets.forEach(ticket => {
            ticket.bets.forEach(bet => {
                const game = bet.game;
                if (!gameStats[game]) {
                    gameStats[game] = { count: 0, amount: 0 };
                }
                gameStats[game].count++;
                gameStats[game].amount += bet.amount;
            });
        });

        const report = {
            totalTickets,
            totalBets,
            totalSales,
            totalWins,
            totalLoss,
            balance,
            gameStats,
            date: today
        };

        res.json(report);
    } catch (error) {
        console.error('Daily report error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// ==================== ROUTES SUPERVISEUR ====================

// Obtenir les agents d'un superviseur
app.get('/api/supervisor/agents', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'supervisor') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© aux superviseurs' });
        }

        const agents = await User.find({ 
            supervisorId: req.user.userId,
            role: 'agent'
        }).select('-password');

        // Ajouter les statistiques pour chaque agent
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);

        const agentsWithStats = await Promise.all(agents.map(async (agent) => {
            const tickets = await Ticket.find({
                agentId: agent.userId,
                date: { $gte: today, $lt: tomorrow }
            });

            const todaySales = tickets.reduce((sum, ticket) => sum + ticket.total, 0);
            const ticketCount = tickets.length;
            const totalWins = tickets.reduce((sum, ticket) => 
                sum + ticket.bets.reduce((betSum, bet) => betSum + (bet.gain || 0), 0), 0);

            return {
                ...agent.toObject(),
                todaySales,
                ticketCount,
                totalWins,
                lastActivity: tickets[0]?.date || agent.createdAt,
                online: agent.online
            };
        }));

        res.json(agentsWithStats);
    } catch (error) {
        console.error('Supervisor agents error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Obtenir les tickets des agents d'un superviseur
app.get('/api/supervisor/tickets', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'supervisor') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© aux superviseurs' });
        }

        // Trouver tous les agents du superviseur
        const agents = await User.find({ 
            supervisorId: req.user.userId,
            role: 'agent'
        }).select('userId');

        const agentIds = agents.map(agent => agent.userId);
        
        const { startDate, endDate, agentId } = req.query;
        let query = { agentId: { $in: agentIds } };
        
        if (agentId) {
            query.agentId = agentId;
        }
        
        if (startDate && endDate) {
            query.date = {
                $gte: new Date(startDate),
                $lte: new Date(endDate)
            };
        }
        
        const tickets = await Ticket.find(query)
            .sort({ date: -1 })
            .limit(100);
        
        res.json(tickets);
    } catch (error) {
        console.error('Supervisor tickets error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Supprimer un ticket (superviseur seulement)
app.delete('/api/supervisor/tickets/:ticketId', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'supervisor') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© aux superviseurs' });
        }

        const ticket = await Ticket.findOne({ ticketId: req.params.ticketId });
        
        if (!ticket) {
            return res.status(404).json({ error: 'Ticket non trouvÃ©' });
        }

        // VÃ©rifier que le ticket appartient Ã  un agent du superviseur
        const agent = await User.findOne({ 
            userId: ticket.agentId,
            supervisorId: req.user.userId
        });

        if (!agent) {
            return res.status(403).json({ error: 'Ticket non accessible' });
        }

        // VÃ©rifier si le ticket a moins de 10 minutes
        const ticketAge = (new Date() - ticket.date) / (1000 * 60);
        if (ticketAge > 10) {
            return res.status(400).json({ error: 'Seuls les tickets de moins de 10 minutes peuvent Ãªtre supprimÃ©s' });
        }

        await Ticket.deleteOne({ ticketId: req.params.ticketId });

        // Log d'activitÃ©
        await ActivityLog.create({
            action: 'TICKET_DELETED',
            userId: req.user.userId,
            userRole: req.user.role,
            details: { ticketId: ticket.ticketId, agentId: ticket.agentId }
        });

        res.json({ success: true, message: 'Ticket supprimÃ©' });
    } catch (error) {
        console.error('Delete ticket error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// ==================== ROUTES PROPRIÃ‰TAIRE ====================

// Gestion des utilisateurs
app.get('/api/owner/users', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'owner') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© au propriÃ©taire' });
        }

        const users = await User.find().select('-password').sort({ role: 1, createdAt: -1 });
        res.json(users);
    } catch (error) {
        console.error('Get users error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// CrÃ©er un utilisateur
app.post('/api/owner/users', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'owner') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© au propriÃ©taire' });
        }

        const { userId, name, password, role, supervisorId, location, commission, email, phone } = req.body;
        
        // Validation
        if (!userId || !name || !password || !role) {
            return res.status(400).json({ error: 'Champs requis manquants' });
        }

        // VÃ©rifier si l'utilisateur existe dÃ©jÃ 
        const existingUser = await User.findOne({ userId });
        if (existingUser) {
            return res.status(400).json({ error: 'Cet identifiant existe dÃ©jÃ ' });
        }

        // VÃ©rifier le superviseur si c'est un agent
        if (role === 'agent' && supervisorId) {
            const supervisor = await User.findOne({ userId: supervisorId, role: 'supervisor' });
            if (!supervisor) {
                return res.status(400).json({ error: 'Superviseur invalide' });
            }
        }

        // CrÃ©er l'utilisateur
        const user = await User.create({
            userId,
            name,
            password, // Pas de hash comme demandÃ©
            role,
            supervisorId: role === 'agent' ? supervisorId : null,
            location: location || '',
            commission: commission || (role === 'agent' ? 5 : 0),
            email: email || '',
            phone: phone || ''
        });

        // Log d'activitÃ©
        await ActivityLog.create({
            action: 'USER_CREATED',
            userId: req.user.userId,
            userRole: req.user.role,
            details: { newUserId: userId, role, name }
        });

        res.status(201).json({ 
            success: true, 
            message: 'Utilisateur crÃ©Ã© avec succÃ¨s',
            user: await User.findById(user._id).select('-password')
        });
    } catch (error) {
        console.error('Create user error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Bloquer/DÃ©bloquer un utilisateur
app.put('/api/owner/users/:userId/block', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'owner') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© au propriÃ©taire' });
        }

        const { blocked } = req.body;
        const user = await User.findOneAndUpdate(
            { userId: req.params.userId },
            { blocked, online: blocked ? false : user.online },
            { new: true }
        ).select('-password');

        if (!user) {
            return res.status(404).json({ error: 'Utilisateur non trouvÃ©' });
        }

        // Log d'activitÃ©
        await ActivityLog.create({
            action: blocked ? 'USER_BLOCKED' : 'USER_UNBLOCKED',
            userId: req.user.userId,
            userRole: req.user.role,
            details: { targetUserId: req.params.userId, name: user.name }
        });

        res.json({ 
            success: true, 
            message: `Utilisateur ${blocked ? 'bloquÃ©' : 'dÃ©bloquÃ©'}`,
            user 
        });
    } catch (error) {
        console.error('Block user error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Gestion des tirages
app.get('/api/owner/draws', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'owner') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© au propriÃ©taire' });
        }

        const draws = await Draw.find().sort({ time: 1 });
        res.json(draws);
    } catch (error) {
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Activer/DÃ©sactiver un tirage
app.put('/api/owner/draws/:drawId/status', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'owner') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© au propriÃ©taire' });
        }

        const { active } = req.body;
        const draw = await Draw.findOneAndUpdate(
            { drawId: req.params.drawId },
            { active },
            { new: true }
        );

        if (!draw) {
            return res.status(404).json({ error: 'Tirage non trouvÃ©' });
        }

        // Log d'activitÃ©
        await ActivityLog.create({
            action: active ? 'DRAW_ACTIVATED' : 'DRAW_DEACTIVATED',
            userId: req.user.userId,
            userRole: req.user.role,
            details: { drawId: draw.drawId, name: draw.name }
        });

        res.json({ 
            success: true, 
            message: `Tirage ${active ? 'activÃ©' : 'dÃ©sactivÃ©'}`,
            draw 
        });
    } catch (error) {
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Publier des rÃ©sultats
app.post('/api/owner/draws/:drawId/results', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'owner') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© au propriÃ©taire' });
        }

        const { lot1, lot2, lot3 } = req.body;
        
        if (!lot1 || !lot2 || !lot3) {
            return res.status(400).json({ error: 'Les 3 rÃ©sultats sont requis' });
        }

        const draw = await Draw.findOneAndUpdate(
            { drawId: req.params.drawId },
            { 
                $set: { 
                    'results.lot1': lot1.toString().padStart(2, '0'),
                    'results.lot2': lot2.toString().padStart(2, '0'),
                    'results.lot3': lot3.toString().padStart(2, '0'),
                    'results.publishedAt': new Date()
                }
            },
            { new: true }
        );

        if (!draw) {
            return res.status(404).json({ error: 'Tirage non trouvÃ©' });
        }

        // VÃ©rifier les tickets gagnants
        const tickets = await Ticket.find({ 
            drawId: req.params.drawId,
            checked: false 
        });

        for (const ticket of tickets) {
            let totalGain = 0;
            
            for (const bet of ticket.bets) {
                // Logique de calcul des gains (Ã  adapter selon vos rÃ¨gles)
                if (bet.game === 'borlette') {
                    if (bet.cleanNumber === lot1.toString().padStart(2, '0')) {
                        bet.gain = bet.amount * 60;
                    } else if (bet.cleanNumber === lot2.toString().padStart(2, '0')) {
                        bet.gain = bet.amount * 20;
                    } else if (bet.cleanNumber === lot3.toString().padStart(2, '0')) {
                        bet.gain = bet.amount * 10;
                    }
                }
                totalGain += bet.gain || 0;
            }
            
            ticket.checked = true;
            await ticket.save();
        }

        // Log d'activitÃ©
        await ActivityLog.create({
            action: 'RESULTS_PUBLISHED',
            userId: req.user.userId,
            userRole: req.user.role,
            details: { 
                drawId: draw.drawId, 
                name: draw.name,
                results: { lot1, lot2, lot3 }
            }
        });

        res.json({ 
            success: true, 
            message: 'RÃ©sultats publiÃ©s et gains calculÃ©s',
            draw 
        });
    } catch (error) {
        console.error('Publish results error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Gestion des nombres bloquÃ©s
app.get('/api/owner/blocked-numbers', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'owner') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© au propriÃ©taire' });
        }

        const blockedNumbers = await BlockedItem.find({ type: 'number' });
        const numberLimits = await NumberLimit.find();
        
        res.json({ blockedNumbers, numberLimits });
    } catch (error) {
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.post('/api/owner/blocked-numbers', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'owner') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© au propriÃ©taire' });
        }

        const { numbers, reason } = req.body;
        
        if (!numbers || !Array.isArray(numbers)) {
            return res.status(400).json({ error: 'Liste de nombres requise' });
        }

        const blockedItems = [];
        for (const number of numbers) {
            const blockedItem = await BlockedItem.create({
                type: 'number',
                value: number.toString().padStart(2, '0'),
                reason: reason || 'BloquÃ© par le propriÃ©taire',
                blockedBy: req.user.userId
            });
            blockedItems.push(blockedItem);
        }

        res.status(201).json({ 
            success: true, 
            message: `${numbers.length} nombre(s) bloquÃ©(s)`,
            blockedItems 
        });
    } catch (error) {
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Rapports du propriÃ©taire
app.get('/api/owner/reports/summary', authenticate, async (req, res) => {
    try {
        if (req.user.role !== 'owner') {
            return res.status(403).json({ error: 'AccÃ¨s rÃ©servÃ© au propriÃ©taire' });
        }

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);

        // Statistiques globales
        const totalUsers = await User.countDocuments();
        const totalAgents = await User.countDocuments({ role: 'agent' });
        const totalSupervisors = await User.countDocuments({ role: 'supervisor' });
        const onlineUsers = await User.countDocuments({ online: true });

        // Ventes du jour
        const tickets = await Ticket.find({
            date: { $gte: today, $lt: tomorrow }
        });

        const totalSales = tickets.reduce((sum, ticket) => sum + ticket.total, 0);
        const totalTickets = tickets.length;
        const totalWins = tickets.reduce((sum, ticket) => 
            sum + ticket.bets.reduce((betSum, bet) => betSum + (bet.gain || 0), 0), 0);

        // Ventes par tirage
        const draws = await Draw.find();
        const drawStats = await Promise.all(draws.map(async (draw) => {
            const drawTickets = await Ticket.find({
                drawId: draw.drawId,
                date: { $gte: today, $lt: tomorrow }
            });
            
            const sales = drawTickets.reduce((sum, ticket) => sum + ticket.total, 0);
            return {
                drawId: draw.drawId,
                name: draw.name,
                sales,
                ticketCount: drawTickets.length,
                active: draw.active
            };
        }));

        const summary = {
            users: {
                total: totalUsers,
                agents: totalAgents,
                supervisors: totalSupervisors,
                online: onlineUsers
            },
            sales: {
                total: totalSales,
                tickets: totalTickets,
                wins: totalWins,
                balance: totalWins - totalSales
            },
            draws: drawStats,
            date: today
        };

        res.json(summary);
    } catch (error) {
        console.error('Owner report error:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// ==================== ROUTES COMMUNES ====================

// Obtenir le profil utilisateur
app.get('/api/profile', authenticate, async (req, res) => {
    try {
        res.json({
            success: true,
            user: {
                userId: req.user.userId,
                name: req.user.name,
                role: req.user.role,
                location: req.user.location,
                commission: req.user.commission,
                email: req.user.email,
                phone: req.user.phone,
                supervisorId: req.user.supervisorId,
                online: req.user.online,
                blocked: req.user.blocked,
                createdAt: req.user.createdAt
            }
        });
    } catch (error) {
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Mettre Ã  jour le profil
app.put('/api/profile', authenticate, async (req, res) => {
    try {
        const { name, email, phone, location, password } = req.body;
        
        const updates = {};
        if (name) updates.name = name;
        if (email) updates.email = email;
        if (phone) updates.phone = phone;
        if (location) updates.location = location;
        if (password) updates.password = password; // Pas de hash

        const user = await User.findOneAndUpdate(
            { userId: req.user.userId },
            updates,
            { new: true }
        ).select('-password');

        res.json({ 
            success: true, 
            message: 'Profil mis Ã  jour',
            user 
        });
    } catch (error) {
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Port d'Ã©coute
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`ğŸš€ Serveur dÃ©marrÃ© sur le port ${PORT}`);
    console.log(`ğŸ“Š MongoDB: ${mongoose.connection.readyState === 1 ? 'ConnectÃ©' : 'DÃ©connectÃ©'}`);
});